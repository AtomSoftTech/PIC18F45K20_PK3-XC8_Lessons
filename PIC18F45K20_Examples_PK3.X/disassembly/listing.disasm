Disassembly Listing for HelloLED
Generated From:
C:/Users/Omar/MPLABXProjects/HelloLED.X/dist/18F45K20_PK3_XC8_FREE/debug/HelloLED.X.debug.elf
Jul 11, 2014 3:31:16 PM

---  C:/Users/Omar/MPLABXProjects/HelloLED.X/main.c  ----------------------------------------------------
1:             /* 
2:              * File:   main.c
3:              * Author: Omar
4:              *
5:              * Created on July 7, 2014, 4:53 PM
6:              */
7:             
8:             #include <xc.h>
9:             #include "config.h"
10:            #include <stdint.h>
11:            #include <stdbool.h>
12:            #include <math.h>
13:            #include <delays.h>
14:            #include <flash.h>
15:            
16:            #define _XTAL_FREQ 1000000 // 1 MHz
17:            
18:            //-----------------------------------
19:            #define ACTIVATE_EXAMPLE 11
20:            //-----------------------------------
21:            
22:            #if (ACTIVATE_EXAMPLE == 11)
23:            /* #11
24:             * 
25:             */
26:            uint8_t ProgMemRdAddress(uint16_t address);
27:            void ProgMemErase64(uint16_t address);
28:            void ProgMemWr32(uint16_t address, char *buffer_ptr);
29:            
30:            const char hello_str[] @0x100 = "Hello!";
31:            const char mchp_str[] @0x108 = "Microchip";
32:            const char fill_60[] @0x112 = "012345678901234567890123456789012345678901234567890123456789";
33:            
34:            void main(void) @0x280 {
35:                const char *rom_pointer; //Pointer to program memory
36:                char singlechar = '?';
0280  0E3F     MOVLW 0x3F
0282  6E38     MOVWF singlechar, ACCESS
37:                char i = 0;
0284  0E00     MOVLW 0x0
0286  6E39     MOVWF i, ACCESS
38:                char Alphabet[32];
39:            
40:                // read using a pointer to data
41:                rom_pointer = hello_str; // = &hello_str[0]
0288  0E00     MOVLW 0x0
028A  6E37     MOVWF 0x37, ACCESS
028C  0E01     MOVLW 0x1
028E  6E36     MOVWF 0x36, ACCESS
0290  0E00     MOVLW 0x0
0292  6E35     MOVWF rom_pointer, ACCESS
42:            
43:                do {
44:                    singlechar = *(rom_pointer + i++);
0294  5039     MOVF i, W, ACCESS
0296  0D01     MULLW 0x1
0298  50F3     MOVF PROD, W, ACCESS
029A  2435     ADDWF rom_pointer, W, ACCESS
029C  6E12     MOVWF 0x12, ACCESS
029E  50F4     MOVF PRODH, W, ACCESS
02A0  2036     ADDWFC 0x36, W, ACCESS
02A2  6E13     MOVWF 0x13, ACCESS
02A4  0E00     MOVLW 0x0
02A6  2037     ADDWFC 0x37, W, ACCESS
02A8  6E14     MOVWF 0x14, ACCESS
02AA  C012     MOVFF 0x12, TBLPTR
02AC  FFF6     NOP
02AE  C013     MOVFF 0x13, TBLPTRH
02B0  FFF7     NOP
02B2  C014     MOVFF 0x14, TBLPTRU
02B4  FFF8     NOP
02B6  0008     TBLRD*
02B8  CFF5     MOVFF TABLAT, singlechar
02BA  F038     NOP
02BC  2A39     INCF i, F, ACCESS
45:                } while (singlechar != 0); // string is terminated with 0x00 value.
02BE  6638     TSTFSZ singlechar, ACCESS
02C0  D7E9     BRA 0x294
46:            
47:                // read at specific address
48:                singlechar = ProgMemRdAddress((uint16_t) mchp_str); // returns 'M' from "Microchip".
02C2  0E01     MOVLW 0x1
02C4  6E02     MOVWF 0x2, ACCESS
02C6  0E08     MOVLW 0x8
02C8  6E01     MOVWF __pcstackCOMRAM, ACCESS
02CA  ECBB     CALL 0x776, 0
02CC  F003     NOP
02CE  6E38     MOVWF singlechar, ACCESS
49:            
50:                // Erase the 64 bytes starting at 0x100
51:                ProgMemErase64(0x100);
02D0  0E01     MOVLW 0x1
02D2  6E02     MOVWF 0x2, ACCESS
02D4  0E00     MOVLW 0x0
02D6  6E01     MOVWF __pcstackCOMRAM, ACCESS
02D8  EC99     CALL 0x732, 0
02DA  F003     NOP
52:                ProgMemErase64(0x140);
02DC  0E01     MOVLW 0x1
02DE  6E02     MOVWF 0x2, ACCESS
02E0  0E40     MOVLW 0x40
02E2  6E01     MOVWF __pcstackCOMRAM, ACCESS
02E4  EC99     CALL 0x732, 0
02E6  F003     NOP
53:            
54:                // create a RAM buffer with the uppercase alphabet in ASCII plus the characters [\]^_`
55:                for (i = 0; i < 32; i++) {
02E8  0E00     MOVLW 0x0
02EA  6E39     MOVWF i, ACCESS
02EC  D00C     BRA 0x306
0304  2A39     INCF i, F, ACCESS
0306  0E1F     MOVLW 0x1F
0308  6439     CPFSGT i, ACCESS
030A  D7F1     BRA 0x2EE
56:                    Alphabet[i] = 'A' + i;
02EE  5039     MOVF i, W, ACCESS
02F0  0D01     MULLW 0x1
02F2  0E15     MOVLW 0x15
02F4  24F3     ADDWF PROD, W, ACCESS
02F6  6ED9     MOVWF FSR2, ACCESS
02F8  0E00     MOVLW 0x0
02FA  20F4     ADDWFC PRODH, W, ACCESS
02FC  6EDA     MOVWF FSR2H, ACCESS
02FE  5039     MOVF i, W, ACCESS
0300  0F41     ADDLW 0x41
0302  6EDF     MOVWF INDF2, ACCESS
57:                }
58:                // write the buffer into program memory
59:                ProgMemWr32(0x100, &Alphabet[0]);
030C  0E01     MOVLW 0x1
030E  6E02     MOVWF 0x2, ACCESS
0310  0E00     MOVLW 0x0
0312  6E01     MOVWF __pcstackCOMRAM, ACCESS
0314  0E00     MOVLW 0x0
0316  6E04     MOVWF 0x4, ACCESS
0318  0E15     MOVLW 0x15
031A  6E03     MOVWF buffer_ptr, ACCESS
031C  EC6C     CALL 0x6D8, 0
031E  F003     NOP
60:            
61:                WriteBlockFlash(0x100,1,&Alphabet[0]);
0320  0E00     MOVLW 0x0
0322  6E01     MOVWF __pcstackCOMRAM, ACCESS
0324  0E01     MOVLW 0x1
0326  6E02     MOVWF 0x2, ACCESS
0328  0E00     MOVLW 0x0
032A  6E03     MOVWF buffer_ptr, ACCESS
032C  0E00     MOVLW 0x0
032E  6E04     MOVWF 0x4, ACCESS
0330  0E01     MOVLW 0x1
0332  6E05     MOVWF num_blocks, ACCESS
0334  0E00     MOVLW 0x0
0336  6E07     MOVWF 0x7, ACCESS
0338  0E15     MOVLW 0x15
033A  6E06     MOVWF ptr, ACCESS
033C  EC01     CALL 0x602, 0
033E  F003     NOP
62:                while (1) {
0340  D7FF     BRA 0x340
63:                    ;
64:                } // all done
65:            
66:            }
67:            
68:            uint8_t ProgMemRdAddress(uint16_t address) { // reads and returns the flash program memory byte value at the 16-bit address given
69:                // given in "address".
70:            
71:                const unsigned char *ptr; // Pointer to rom
72:            
73:                ptr = (const unsigned char *) address; // Get the value
0776  C001     MOVFF __pcstackCOMRAM, buffer_ptr
0778  F003     NOP
077A  C002     MOVFF 0x2, 0x4
077C  F004     NOP
077E  6A05     CLRF num_blocks, ACCESS
0780  C003     MOVFF buffer_ptr, ptr
0782  F006     NOP
0784  C004     MOVFF 0x4, 0x7
0786  F007     NOP
0788  C005     MOVFF num_blocks, 0x8
078A  F008     NOP
74:            
75:                return *ptr;
078C  C006     MOVFF ptr, TBLPTR
76:            }
77:            
78:            void ProgMemErase64(uint16_t address) { // the program memory of the PIC18F4520 is erased 64-bytes at a time, which must
79:                // aligned on a 64-byte address boundary
80:                const unsigned char *ptr;
81:            
82:                // assigning the pointer sets the TBLPTRU:TBLPTRH:TBLPTRL SFR registers
83:                ptr = (const unsigned char *) (address & 0xFFC0); // ensure erase starts on 64-byte boundary
0732  0EC0     MOVLW 0xC0
0734  6E03     MOVWF buffer_ptr, ACCESS
0736  0EFF     MOVLW 0xFF
0738  6E04     MOVWF 0x4, ACCESS
073A  C001     MOVFF __pcstackCOMRAM, num_blocks
073C  F005     NOP
073E  C002     MOVFF 0x2, ptr
0740  F006     NOP
0742  5003     MOVF buffer_ptr, W, ACCESS
0744  1605     ANDWF num_blocks, F, ACCESS
0746  5004     MOVF 0x4, W, ACCESS
0748  1606     ANDWF ptr, F, ACCESS
074A  C005     MOVFF num_blocks, 0x7
074C  F007     NOP
074E  C006     MOVFF ptr, 0x8
0750  F008     NOP
0752  6A09     CLRF ptr, ACCESS
0754  C007     MOVFF 0x7, ptr
0756  F00A     NOP
0758  C008     MOVFF 0x8, i
075A  F00B     NOP
075C  C009     MOVFF ptr, write_byte
075E  F00C     NOP
84:            
85:                // set up the erase.  Program execution will be suspended during the flash erase
86:                EECON1bits.EEPGD = 1; // point to flash program memory
0760  8EA6     BSF EECON1, 7, ACCESS
87:                EECON1bits.CFGS = 0; // not configuration registers
0762  9CA6     BCF EECON1, 6, ACCESS
88:                EECON1bits.FREE = 1; // we're erasing
0764  88A6     BSF EECON1, 4, ACCESS
89:                EECON1bits.WREN = 1; // enable write/erase operations
0766  84A6     BSF EECON1, 2, ACCESS
90:            
91:                // execute code sequence, which cannot be interrupted, then execute erase
92:            
93:                //INTCONbits.GIE = 0;   // Disable interrupts
94:                EECON2 = 0x55; // Begin Write sequence
0768  0E55     MOVLW 0x55
076A  6EA7     MOVWF EECON2, ACCESS
95:                EECON2 = 0xAA;
076C  0EAA     MOVLW 0xAA
076E  6EA7     MOVWF EECON2, ACCESS
96:                EECON1bits.WR = 1; // Set WR bit to begin 64-byte erase
0770  82A6     BSF EECON1, 1, ACCESS
97:                //INTCONbits.GIE = 1;   // re-enable interrupts
98:            
99:                EECON1bits.WREN = 0; // disable write/erase operations
0772  94A6     BCF EECON1, 2, ACCESS
100:           }
0774  0012     RETURN 0
101:           
102:           void ProgMemWr32(uint16_t address, char *buffer_ptr) { // program memory must be written 32 bytes at a time in the PIC18F4520, starting at a
103:               // 32-byte address boundary.  It must also be erased first.
104:               const unsigned char *ptr;
105:               char i;
106:           
107:               ptr = (unsigned char *) (address & 0xFFE0); // ensure write starts on 32-byte boundary
06D8  0EE0     MOVLW 0xE0
06DA  6E05     MOVWF num_blocks, ACCESS
06DC  0EFF     MOVLW 0xFF
06DE  6E06     MOVWF ptr, ACCESS
06E0  C001     MOVFF __pcstackCOMRAM, 0x7
06E2  F007     NOP
06E4  C002     MOVFF 0x2, 0x8
06E6  F008     NOP
06E8  5005     MOVF num_blocks, W, ACCESS
06EA  1607     ANDWF 0x7, F, ACCESS
06EC  5006     MOVF ptr, W, ACCESS
06EE  1608     ANDWF 0x8, F, ACCESS
06F0  C007     MOVFF 0x7, ptr
06F2  F009     NOP
06F4  C008     MOVFF 0x8, ptr
06F6  F00A     NOP
108:           
109:               for (i = 0; i < 32; i++) {
06F8  0E00     MOVLW 0x0
06FA  6E0B     MOVWF i, ACCESS
06FC  D00C     BRA 0x716
0714  2A0B     INCF i, F, ACCESS
0716  0E1F     MOVLW 0x1F
0718  640B     CPFSGT i, ACCESS
071A  D7F1     BRA 0x6FE
110:                   TABLAT = buffer_ptr[i]; // write the data into the holding registers
06FE  500B     MOVF i, W, ACCESS
0700  0D01     MULLW 0x1
0702  50F3     MOVF PROD, W, ACCESS
0704  2403     ADDWF buffer_ptr, W, ACCESS
0706  6ED9     MOVWF FSR2, ACCESS
0708  50F4     MOVF PRODH, W, ACCESS
070A  2004     ADDWFC 0x4, W, ACCESS
070C  6EDA     MOVWF FSR2H, ACCESS
070E  50DF     MOVF INDF2, W, ACCESS
0710  6EF5     MOVWF TABLAT, ACCESS
111:                   asm("TBLWT+*");
0712  000F     TBLWT+*
112:                   //*(ptr + 1) = buffer_ptr[i]; // write the data into the holding registers
113:               }
114:           
115:               // NOTE! When writing program memory flash, the TBLPTRU:TBLPTRH:TBLPTRL registers
116:               // must be pointing within the 32-byte block intended to be written.  For example,
117:               // if you wish to write 32 bytes at 0x100, if the last write increments the pointer
118:               // past 0x11F to 0x120, the 32 bytes will actually be written at 0x120, not 0x100.
119:           
120:               EECON1bits.EEPGD = 1; // write to flash program memory
071C  8EA6     BSF EECON1, 7, ACCESS
121:               EECON1bits.CFGS = 0; // not configuration registers
071E  9CA6     BCF EECON1, 6, ACCESS
122:               EECON1bits.FREE = 0; // we're not erasing now.
0720  98A6     BCF EECON1, 4, ACCESS
123:               EECON1bits.WREN = 1; // enable write/erase operations
0722  84A6     BSF EECON1, 2, ACCESS
124:           
125:               // execute code sequence, which cannot be interrupted, then execute write32
126:           
127:               //INTCONbits.GIE = 0;   // Disable interrupts
128:               EECON2 = 0x55; // Begin Write sequence
0724  0E55     MOVLW 0x55
0726  6EA7     MOVWF EECON2, ACCESS
129:               EECON2 = 0xAA;
0728  0EAA     MOVLW 0xAA
072A  6EA7     MOVWF EECON2, ACCESS
130:               EECON1bits.WR = 1; // Set WR bit to begin 32-byte write
072C  82A6     BSF EECON1, 1, ACCESS
131:               //INTCONbits.GIE = 1;   // re-enable interrupts
132:           
133:               EECON1bits.WREN = 0; // disable write/erase operations
072E  94A6     BCF EECON1, 2, ACCESS
134:           }
0730  0012     RETURN 0
135:           #endif
136:           
137:           #if (ACTIVATE_EXAMPLE == 112)
138:           /* #11
139:            * Write and Read Program memory (using xc8 libraries)
140:            *
141:            * Notes:
142:            * - Before write data you must erase the block.
143:            * - Erase and Write must be in term of blocks (Defined in datasheet)
144:            * - Read can be done in any adrress (no block term is needed)
145:            *
146:            * PIC18F45K22:
147:            * Erase block = 64 Bytes
148:            * Write Block = 32 Bytes
149:            */
150:           unsigned char data[] = {0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81};
151:           unsigned char read_data[8];
152:           
153:           void main(void) @0x1000 { // Put main in 1000h
154:               TRISD = 0x00;
155:               LATD = 0;
156:           
157:               // Erase block = 64 Bytes = 0x40
158:               // Write block = 32 Bytes = 0x20
159:               // Address = 0 - > (block term) (Example: Erase Block 1 = 0x00 -> 0x3F, Erase Block 2 = 0x40 -> 0x7F
160:               EraseFlash(0x500, 0x53F); // Erase 64 bytes (One erase block)
161:           
162:               WriteBytesFlash(0x510, sizeof (data), &data[0]); // Write to any address previously erased (it doesn't need to be the start of a block address).
163:               //WriteBlockFlash(0x500,1,&data[0]); // Write one block (32 Bytes), address must be in write block term and all the 32 Bytes must be present in the array. If you dont need all 32 Bytes you can fill them with 0xFF
164:           
165:               ReadFlash(0x510, sizeof (read_data), &read_data[0]); // Read bytes from program memory (Any address and the needed amount of bytes))
166:           
167:               while (1) {
168:                   for (unsigned char x = 0; x < 8; x++) {
169:                       LATD = read_data[x]; // Read address value
170:                       __delay_ms(200);
171:                   }
172:               }
173:           }
174:           #endif
175:           
176:           #if (ACTIVATE_EXAMPLE == 111)
177:           /* #11
178:            * Read program memory (data stored in code when programmed)
179:            */
180:           const unsigned char id_rom[] @(0x500) = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
181:           
182:           void main(void) {
183:               TRISD = 0x00;
184:               LATD = 0;
185:           
186:               while (1) {
187:                   const unsigned char *pt;
188:                   pt = (const unsigned char*) 0x500; // Pointing to rom address
189:                   //pt = &id_rom[0]; // Pointing to rom address
190:                   for (unsigned char x = 0; x < 8; x++) {
191:                       LATD = *pt; // Read address value
192:                       pt++; // Point to next byte
193:                       __delay_ms(500);
194:                   }
195:               }
196:           }
197:           #endif
198:           
199:           #if (ACTIVATE_EXAMPLE == 10)
200:           /* #10
201:            * EEPROM read, write and initialize
202:            */
203:           
204:           void e2prom_write(unsigned char, unsigned char);
205:           unsigned char e2prom_read(unsigned char);
206:           
207:           // Diferentes ways to load data to eeprom
208:           
209:           // (Pre-loading) This macro only permits to write 8 bytes of data in 0x00-0x07 address
210:           //__EEPROM_DATA(0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80);
211:           
212:           // (Pre-loading) Using this macro more than one time will continue the next address data
213:           //__EEPROM_DATA(0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80);
214:           //__EEPROM_DATA(0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01);
215:           
216:           void main(void) {
217:               TRISD = 0x00; // Output
218:               LATD = 0x00; // Turn off leds
219:           
220:               // (In runtime) Using a user defined function or xc8 function
221:               for (unsigned char a = 0, d = 1; a < 8; a++, d = d << 1) {
222:                   //e2prom_write(a,d); // User function
223:                   eeprom_write(a, d); // xc8 function
224:               }
225:           
226:               while (1) {
227:                   for (unsigned char a = 0; a < 16; a++) {
228:                       //LATD = e2prom_read(a); // User function
229:                       LATD = eeprom_read(a); // xc8 function
230:                       __delay_ms(500);
231:                   }
232:               }
233:           }
234:           
235:           void e2prom_write(unsigned char address, unsigned char value) {
236:               PIR2bits.EEIF = 0; // Erase interrupt flag
237:           
238:               EECON1bits.EEPGD = 0; // Point to DATA memory
239:               EECON1bits.CFGS = 0; // Access E2PROM
240:           
241:               EEADR = address; // Write address
242:               EEDATA = value; // Write data
243:               EECON1bits.WREN = 1; // Enable write
244:           
245:               INTCONbits.GIE = 0; // Disable interrupts
246:           
247:               // Write sequence
248:               EECON2 = 0x55;
249:               EECON2 = 0xAA;
250:               EECON1bits.WR = 1; // Set WR bit to begin write
251:           
252:               INTCONbits.GIE = 1; // Enable interrupts
253:           
254:               while (PIR2bits.EEIF == 0); // Wait for write to finish
255:           
256:               EECON1bits.WREN = 0; // Disable write
257:           }
258:           
259:           unsigned char e2prom_read(unsigned char address) {
260:               EECON1bits.EEPGD = 0; // Point to DATA memory
261:               EECON1bits.CFGS = 0; // Access EEPROM
262:           
263:               EEADR = address; // Load address
264:           
265:               EECON1bits.RD = 1; // Read
266:               return EEDATA;
267:           }
268:           #endif
269:           
270:           #if (ACTIVATE_EXAMPLE == 91)
271:           
272:           /* #91
273:            * OSC Frequency
274:            */
275:           #define _XTAL_FREQ 1000000 // 1 MHz
276:           
277:           void main(void) {
278:               TRISD = 0x00; // outputs
279:               while (1) {
280:                   OSCCONbits.IRCF = 0b011; // 1MHz
281:                   OSCTUNEbits.PLLEN = 0; // = 1MHz
282:                   for (unsigned char i = 1; i > 0; i = i << 1) {
283:                       LATD = i;
284:                       __delay_ms(500);
285:                       __delay_ms(500);
286:                   }
287:                   OSCCONbits.IRCF = 0b111; // 16MHz
288:                   OSCTUNEbits.PLLEN = 1; // PLL on = 16MHz x 4 = 64MHz
289:                   for (unsigned char x = 0; x < 10; x++) {
290:                       for (unsigned char i = 1; i > 0; i = i << 1) {
291:                           LATD = i;
292:                           __delay_ms(500); // not real 500ms because the cpu is runing at 64mhz
293:                           __delay_ms(500);
294:                       }
295:                       for (unsigned char i = 0x80; i > 0; i = i >> 1) {
296:                           LATD = i;
297:                           __delay_ms(500);
298:                           __delay_ms(500);
299:                       }
300:                   }
301:               }
302:           }
303:           #endif
304:           
305:           #if (ACTIVATE_EXAMPLE == 9)
306:           
307:           /* #9
308:            * Change Frequency with INT0 + SW Debounce
309:            */
310:           typedef enum {
311:               C_250kHz = 0,
312:               C_500kHz = 1,
313:               C_1MHz = 2,
314:               C_2MHz = 3,
315:               C_4MHz = 4,
316:               C_8MHz = 5,
317:               C_16MHz = 6,
318:               C_32MHz = 7,
319:               C_64MHz = 8
320:           } IntOSCFreq;
321:           
322:           void InterruptService(void);
323:           void SetupINT0Switch(void);
324:           void EnableInterrupts(void);
325:           void SetIntOSC(IntOSCFreq *ClockSet);
326:           
327:           unsigned char LED_Count = 0; // 8-bit variable
328:           unsigned char SwitchDelay = 1; // delay time to "debounce" switch
329:           IntOSCFreq ClockSpeed = C_250kHz;
330:           
331:           void main(void) {
332:               // Init I/O
333:               TRISD = 0b00000000; // PORTD bits 7:0 are all outputs (0)
334:               TRISEbits.TRISE0 = 1; // TRISE0 input
335:           
336:               // Set initial clock speed (250kHz)
337:               SetIntOSC(&ClockSpeed);
338:           
339:               // Init switch and turn on interrupts
340:               SetupINT0Switch();
341:               EnableInterrupts();
342:           
343:               while (1) { // delay and count on LEDs here.  Interrupt handles switch and freq changes
344:                   LATD = LED_Count++; // output count to PORTD LEDs
345:           
346:                   Delay1KTCYx(64); // delay 64,000 cycles or about 1 sec at 250kHz
347:               }
348:           
349:           }
350:           
351:           void SetupINT0Switch(void) { // Set up switch interrupt on INT0
352:               INTCON2bits.INTEDG0 = 0; // interrupt on falling edge of INT0 (switch pressed)
353:               INTCONbits.INT0IF = 0; // ensure flag is cleared
354:               INTCONbits.INT0IE = 1; // enable INT0 interrupt
355:           }
356:           
357:           void EnableInterrupts(void) { // Set up global interrupts
358:               RCONbits.IPEN = 0; // Disable priority levels on interrupts
359:               INTCONbits.PEIE = 1; // Peripheral interrupts allowed (but none are used)
360:               INTCONbits.GIE = 1; // Interrupting enabled.
361:           }
362:           
363:           void interrupt high_isr(void) {
364:               int i;
365:           
366:               // Check to see what caused the interrupt
367:               // (Necessary when more than 1 interrupt at a priority level)
368:           
369:               // Check for INT0 interrupt
370:               if (INTCONbits.INT0IF) {
371:                   // Delay about 50ms regardless of frequency to debounce switch.
372:                   // NOTE: a delay function from delay.h isn't used as they are
373:                   // inline assembly and inline assembly in an interrupt routine
374:                   // causes a very long context save/restore since the compiler
375:                   // doesn't know what resources are being used and so saves everything.
376:                   i = 125 * SwitchDelay;
377:                   while (i) {
378:                       i--;
379:                   }
380:           
381:           
382:                   // clear (reset) flag
383:                   INTCONbits.INT0IF = 0;
384:           
385:                   if (PORTBbits.RB0 == 0) { // if it's still pressed after 100ms delay.
386:                       // Change oscilator frequency
387:                       SetIntOSC(&ClockSpeed);
388:                   }
389:               }
390:               // Check for another interrupt, examples:
391:               // if (PIR1bits.TMR1IF)     // Timer 1
392:               // if (PIR1bits.ADIF)       // ADC
393:           
394:           } // return from high-priority interrupt
395:           
396:           void SetIntOSC(IntOSCFreq *ClockSet) { // This function sets the internal oscillator to the frequency of
397:               // the ClockSet argument variable, and then increments ClockSet
398:               // to the next supported frequency.
399:               switch (*ClockSet) {
400:                   case C_250kHz:
401:                       OSCCON = 0x10; // IRCFx = 001
402:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
403:                       *ClockSet = C_500kHz;
404:                       SwitchDelay = 1;
405:                       break;
406:           
407:                   case C_500kHz:
408:                       OSCCON = 0x20; // IRCFx = 010
409:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
410:                       *ClockSet = C_1MHz;
411:                       SwitchDelay = 2;
412:                       break;
413:           
414:                   case C_1MHz:
415:                       OSCCON = 0x30; // IRCFx = 011
416:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
417:                       *ClockSet = C_2MHz;
418:                       SwitchDelay = 4;
419:                       break;
420:           
421:                   case C_2MHz:
422:                       OSCCON = 0x40; // IRCFx = 100
423:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
424:                       *ClockSet = C_4MHz;
425:                       SwitchDelay = 8;
426:                       break;
427:           
428:                   case C_4MHz:
429:                       OSCCON = 0x50; // IRCFx = 101
430:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
431:                       *ClockSet = C_8MHz;
432:                       SwitchDelay = 16;
433:                       break;
434:           
435:                   case C_8MHz:
436:                       OSCCON = 0x60; // IRCFx = 110
437:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
438:                       *ClockSet = C_16MHz;
439:                       SwitchDelay = 32;
440:                       break;
441:           
442:                   case C_16MHz:
443:                       OSCCON = 0x70; // IRCFx = 111
444:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
445:                       *ClockSet = C_32MHz;
446:                       SwitchDelay = 64;
447:                       break;
448:           
449:                   case C_32MHz:
450:                       OSCCON = 0x60; // IRCFx = 110 (8 MHz)
451:                       OSCTUNEbits.PLLEN = 1; // x4 PLL enabled = 32MHz
452:                       *ClockSet = C_64MHz;
453:                       SwitchDelay = 128;
454:                       break;
455:           
456:                   case C_64MHz:
457:                       OSCCON = 0x70; // IRCFx = 111 (16 MHz)
458:                       OSCTUNEbits.PLLEN = 1; // x4 PLL enabled = 64MHz
459:                       *ClockSet = C_250kHz;
460:                       SwitchDelay = 255;
461:                       break;
462:           
463:                   default:
464:                       // should never get here, but just in case
465:                       OSCCON = 0x10; // IRCFx = 001
466:                       OSCTUNEbits.PLLEN = 0; // x4 PLL disabled
467:                       *ClockSet = C_500kHz;
468:                       break;
469:               }
470:           }
471:           #endif
472:           
473:           #if (ACTIVATE_EXAMPLE == 8)
474:           /* #8
475:            * SW with INT0 + T0 int + Rotating leds
476:            */
477:           void Timer0_Init(void);
478:           void ADC_Init(void);
479:           unsigned char ADC_Convert(void);
480:           void Interrupts_Init(void);
481:           
482:           #define DetectsInARow   5
483:           
484:           typedef enum {
485:               LEFT2RIGHT,
486:               RIGHT2LEFT
487:           } LEDDirections;
488:           unsigned char LED_Display = 1;
489:           LEDDirections Direction = LEFT2RIGHT;
490:           
491:           void main(void) {
492:               // Init I/O
493:               TRISD = 0b00000000; // PORTD bits 7:0 are all outputs (0)
494:               TRISAbits.TRISA0 = 1; // TRISA0 input
495:           
496:               Timer0_Init(); // Init Timer0
497:               ADC_Init(); // Init ADC
498:               Interrupts_Init(); // Init interrupts
499:           
500:               while (1) {
501:                   LATD = LED_Display;
502:               }
503:           }
504:           
505:           void ADC_Init(void) { // initialize the Analog-To-Digital converter.
506:               ANSEL = 0; //Turn off all other analog inputs
507:               ANSELbits.ANS0 = 1; // Turn on RA0 analog
508:               ADCON1 = 0; // REF = Vss and Vcc
509:               ADCON2 = 0b00111000; // Left Aligment, 20 Tda(40uS), Fosc/2 (2uS)
510:               ADCON0 = 0b00000001; // CH0, ADC on
511:           }
512:           
513:           unsigned char ADC_Convert(void) { // start an ADC conversion and return the 8 most-significant bits of the result
514:               ADCON0bits.GO_DONE = 1; // Start conversion
515:               while (ADCON0bits.GO_DONE == 1); // Wait for it to complete
516:               return ADRESH; // Return high byte of result
517:           }
518:           
519:           void Timer0_Init(void) {
520:               INTCONbits.TMR0IF = 0; // clear roll-over interrupt flag
521:               INTCON2bits.TMR0IP = 0; // Timer0 is low priority interrupt
522:               INTCONbits.TMR0IE = 1; // enable the Timer0 interrupt.
523:           
524:               T0CON = 0b00000001; // prescale 1:4 - about 1 second maximum delay.
525:               TMR0H = 0; // clear timer - always write upper byte first
526:               TMR0L = 0;
527:           
528:               T0CONbits.TMR0ON = 1; // start timer
529:           }
530:           
531:           void Interrupts_Init(void) {
532:               // Set up switch interrupt on INT0
533:               INTCON2bits.INTEDG0 = 0; // interrupt on falling edge of INT0 (switch pressed)
534:               INTCONbits.INT0IF = 0; // ensure flag is cleared
535:               INTCONbits.INT0IE = 1; // enable INT0 interrupt
536:               // NOTE: INT0 is ALWAYS a high priority interrupt
537:           
538:               // Set up global interrupts
539:               RCONbits.IPEN = 1; // Enable priority levels on interrupts
540:               INTCONbits.GIEL = 1; // Low priority interrupts allowed
541:               INTCONbits.GIEH = 1; // Interrupting enabled.
542:           }
543:           
544:           void interrupt high_isr(void) {
545:               // Check to see what caused the interrupt
546:               // (Necessary when more than 1 interrupt at a priority level)
547:           
548:               // Check for INT0 interrupt
549:               if (INTCONbits.INT0IF) {
550:                   // clear (reset) flag
551:                   INTCONbits.INT0IF = 0;
552:           
553:                   // change directions
554:                   if (Direction == LEFT2RIGHT) {
555:                       Direction = RIGHT2LEFT; // change direction
556:                   } else // (Direction == RIGHT2LEFT)
557:                   {
558:                       Direction = LEFT2RIGHT; // change direction
559:                   }
560:               }
561:           
562:               // Check for another interrupt, examples:
563:               // if (PIR1bits.TMR1IF)     // Timer 1
564:               // if (PIR1bits.ADIF)       // ADC
565:           }
566:           
567:           void interrupt low_priority low_isr(void) {
568:               // Check to see what caused the interrupt
569:               // (Necessary when more than 1 interrupt at a priority level)
570:           
571:               // Check for Timer0 Interrupt
572:               if (INTCONbits.TMR0IF) {
573:                   INTCONbits.TMR0IF = 0; // clear (reset) flag
574:           
575:                   // Take an ADC conversion and use it to set Timer0
576:                   TMR0H = ADC_Convert(); // MSB from ADC
577:                   TMR0L = 0; // LSB = 0
578:           
579:                   // update display variable
580:                   if (Direction == LEFT2RIGHT) {
581:                       LED_Display <<= 1; // rotate display by 1 from 0 to 7
582:                       if (LED_Display == 0)
583:                           LED_Display = 1; // rotated bit out, so set bit 0
584:                   } else // (Direction == RIGHT2LEFT)
585:                   {
586:                       LED_Display >>= 1; // rotate display by 1 from 7 to 0
587:                       if (LED_Display == 0)
588:                           LED_Display = 0x80; // rotated bit out, so set bit 7
589:                   }
590:               }
591:           }
592:           #endif
593:           
594:           #if (ACTIVATE_EXAMPLE == 71)
595:           /* #7.1
596:            * ADC value to leds level (No timer and no sw)
597:            */
598:           void ADC_Init(void);
599:           unsigned char ADC_Convert(void);
600:           
601:           void main(void) {
602:               // Init I/O
603:               TRISD = 0b00000000; // PORTD bits 7:0 are all outputs (0)
604:               TRISAbits.TRISA0 = 1; // TRISA0 input
605:           
606:               // Init ADC
607:               ADC_Init();
608:           
609:               while (1) {
610:                   unsigned char adc_val, result;
611:           
612:                   adc_val = ADC_Convert(); // Get adc value
613:                   result = ((unsigned char) (adc_val / 32)) + 1; // Get range / number of leds to turn on
614:                   if (result == 1) { // if 1 check if its below 16 to turn off all leds or turn on just one
615:                       if (adc_val < 16)
616:                           result = 0;
617:                   }
618:                   result = (unsigned char) (pow(2, result)) - 1; // Get the corresponding value to turn on the leds (0,1,3,7,15,31,63,127,255)
619:                   LATD = ~result; // Load value to leds
620:               }
621:           }
622:           
623:           void ADC_Init(void) { // initialize the Analog-To-Digital converter.
624:               ANSEL = 0; //Turn off all other analog inputs
625:               ANSELbits.ANS0 = 1; // Turn on RA0 analog
626:               ADCON1 = 0; // REF = Vss and Vcc
627:               ADCON2 = 0b00111000; // Left Aligment, 20 Tda(40uS), Fosc/2 (2uS)
628:               ADCON0 = 0b00000001; // CH0, ADC on
629:           }
630:           
631:           unsigned char ADC_Convert(void) { // start an ADC conversion and return the 8 most-significant bits of the result
632:               ADCON0bits.GO_DONE = 1; // Start conversion
633:               while (ADCON0bits.GO_DONE == 1); // Wait for it to complete
634:               return ADRESH; // Return high byte of result
635:           }
636:           #endif
637:           
638:           #if (ACTIVATE_EXAMPLE == 7)
639:           /* #7
640:            * ADC value to leds rotate time
641:            */
642:           void Timer0_Init(void);
643:           void ADC_Init(void);
644:           unsigned char ADC_Convert(void);
645:           
646:           #define Switch_Pin      PORTBbits.RB0
647:           #define DetectsInARow   5
648:           
649:           typedef enum {
650:               LEFT2RIGHT,
651:               RIGHT2LEFT
652:           } LEDDirections;
653:           
654:           unsigned char LED_Display; // 8-bit variable
655:           
656:           void main(void) {
657:               LEDDirections Direction = LEFT2RIGHT;
658:               BOOL SwitchPressed = FALSE;
659:           
660:               LED_Display = 1; // initialize
661:           
662:               // Init I/O
663:               TRISD = 0b00000000; // PORTD bits 7:0 are all outputs (0)
664:               TRISAbits.TRISA0 = 1; // TRISA0 input
665:           
666:               INTCON2bits.RBPU = 0; // enable PORTB internal pullups
667:               WPUBbits.WPUB0 = 1; // enable pull up on RB0
668:           
669:               // ADCON1 is now set up in the InitADC() function.
670:               TRISBbits.TRISB0 = 1; // PORTB bit 0 (connected to switch) is input (1)
671:           
672:               // Init Timer0
673:               Timer0_Init();
674:           
675:               // Init ADC
676:               ADC_Init();
677:           
678:               while (1) {
679:           
680:                   if (Direction == LEFT2RIGHT) {
681:                       LED_Display <<= 1; // rotate display by 1 from 0 to 7
682:                       if (LED_Display == 0)
683:                           LED_Display = 1; // rotated bit out, so set bit 0
684:                   }
685:                   if (Direction == RIGHT2LEFT) {
686:                       LED_Display >>= 1; // rotate display by 1 from 7 to 0
687:                       if (LED_Display == 0)
688:                           LED_Display = 0x80; // rotated bit out, so set bit 7
689:                   }
690:           
691:                   LATD = LED_Display; // output LED_Display value to PORTD LEDs
692:           
693:                   do { // poll the switch while waiting for the timer to roll over.
694:                       if (Switch_Pin == 1) { // look for switch released.
695:                           SwitchPressed = FALSE;
696:                       } else if (SwitchPressed == FALSE) // && (Switch_Pin == 0) due to if-else
697:                       { // switch was just pressed
698:                           SwitchPressed = TRUE;
699:                           // change  direction
700:                           if (Direction == LEFT2RIGHT)
701:                               Direction = RIGHT2LEFT;
702:                           else
703:                               Direction = LEFT2RIGHT;
704:                       }
705:           
706:                   } while (INTCONbits.TMR0IF == 0);
707:           
708:                   // Timer expired
709:                   INTCONbits.TMR0IF = 0; // Reset Timer flag
710:           
711:                   // Take an ADC conversion and use it to set Timer0
712:                   TMR0H = ADC_Convert(); // MSB from ADC
713:                   TMR0L = 0; // LSB = 0
714:           
715:               }
716:           
717:           }
718:           
719:           void Timer0_Init(void) {
720:               INTCONbits.TMR0IF = 0; // clear roll-over interrupt flag
721:               T0CON = 0b00000001; // prescale 1:4 - about 1 second maximum delay.
722:               TMR0H = 0; // clear timer - always write upper byte first
723:               TMR0L = 0;
724:               T0CONbits.TMR0ON = 1; // start timer
725:           }
726:           
727:           void ADC_Init(void) { // initialize the Analog-To-Digital converter.
728:               // First, we need to make sure the AN0 pin is enabled as an analog input
729:               // as the demo board potentiometer is connected to RA0/AN0
730:               // Don't forget that RB0/AN12 must be digital!
731:               ANSEL = 0; //turn off all other analog inputs
732:               //ANSELH = 0;
733:               ANSELbits.ANS0 = 1; // turn on RA0 analog
734:           
735:               // Sets bits VCFG1 and VCFG0 in ADCON1 so the ADC voltage reference is VSS to VDD
736:           
737:               ADCON1 = 0;
738:           
739:               // The ADC clock must as short as possible but still greater than the
740:               // minimum TAD time, datasheet parameter 130.  At the time this lesson was
741:               // written TAD minimum for the PIC18F45K20 is 1.4us.
742:               // At 1MHz clock, selecting ADCS = FOSC/2 = 500kHz.  One clock period
743:               // 1 / 500kHz = 2us, which greater than minimum required 1.4us.
744:               // So ADCON2 bits ADCS2-0 = 000
745:               //
746:               // The ACQT aquisition time should take into accound the internal aquisition
747:               // time TACQ of the ADC, datasheet paramter 130, and the settling time of
748:               // of the application circuit connected to the ADC pin.  Since the actual
749:               // settling time of the RC circuit with the demo board potentiometer is very
750:               // long but accuracy is not very important to this demo, we'll set ACQT2-0 to
751:               // 20TAD = 111
752:               //
753:               // ADFM = 0 so we can easily read the 8 Most Significant bits from the ADRESH
754:               // Special Function Register
755:               ADCON2 = 0b00111000;
756:           
757:               // Select channel 0 (AN0) to read the potentiometer voltage and turn on ADC
758:               ADCON0 = 0b00000001;
759:           }
760:           
761:           unsigned char ADC_Convert(void) { // start an ADC conversion and return the 8 most-significant bits of the result
762:               ADCON0bits.GO_DONE = 1; // start conversion
763:               while (ADCON0bits.GO_DONE == 1); // wait for it to complete
764:               return ADRESH; // return high byte of result
765:           }
766:           #endif
767:           
768:           #if (ACTIVATE_EXAMPLE == 6)
769:           /* #6
770:            * Timer0 + Rotate leds direction
771:            */
772:           #define LED_Display LATD
773:           #define Switch_Pin PORTBbits.RB0
774:           
775:           typedef enum {
776:               LEFT2RIGHT, RIGHT2LEFT
777:           } LEDDirections;
778:           
779:           void main(void) {
780:               LEDDirections Direction = LEFT2RIGHT;
781:               BOOL SwitchPressed = FALSE;
782:           
783:               LED_Display = 1; // initialize
784:               TRISD = 0b00000000; // Display Output
785:               TRISBbits.TRISB0 = 1; // SW Input
786:               // Init Timer0
787:               INTCONbits.TMR0IF = 0; // clear flag
788:               T0CON = 0b00001000; // 16b, increments every instruction clock, No prescale
789:               TMR0H = 0;
790:               TMR0L = 0;
791:               T0CONbits.TMR0ON = 1;
792:           
793:               while (1) {
794:                   if (Direction == LEFT2RIGHT) {
795:                       LED_Display <<= 1; // rotate display by 1 from 0 to 7
796:                       if (LED_Display == 0)
797:                           LED_Display = 1; // rotated bit out, so set bit 0
798:                   }
799:                   if (Direction == RIGHT2LEFT) {
800:                       LED_Display >>= 1; // rotate display by 1 from 7 to 0
801:                       if (LED_Display == 0)
802:                           LED_Display = 0x80; // rotated bit out, so set bit 7
803:                   }
804:           
805:                   LATD = LED_Display; // output LED_Display value to PORTD LEDs
806:           
807:                   do { // poll the switch while waiting for the timer to roll over.
808:                       if (Switch_Pin == 1) { // look for switch released.
809:                           SwitchPressed = FALSE;
810:                       } else if (SwitchPressed == FALSE) // && (Switch_Pin == 0) due to if-else
811:                       { // switch was just pressed
812:                           SwitchPressed = TRUE;
813:                           // change  direction
814:                           if (Direction == LEFT2RIGHT)
815:                               Direction = RIGHT2LEFT;
816:                           else
817:                               Direction = LEFT2RIGHT;
818:                       }
819:           
820:                   } while (INTCONbits.TMR0IF == 0);
821:           
822:                   // Timer expired
823:                   INTCONbits.TMR0IF = 0; // Reset Timer flag
824:               }
825:           }
826:           #endif
827:           
828:           #if(ACTIVATE_EXAMPLE == 5)
829:           /* #5
830:            * Read switch with anti-debounce and release count
831:            */
832:           #define _XTAL_FREQ 1000000 // 1 MHz
833:           #define LED_Display LATD
834:           #define SW_pin PORTBbits.RB0
835:           
836:           void main(void) {
837:               TRISD = 0x00; // Display Output
838:               TRISBbits.TRISB0 = 1; // SW Input
839:               while (1) {
840:                   unsigned char t;
841:                   unsigned char s;
842:                   for (t = 0x01; t > 0; t <<= 1) {
843:                       LED_Display = t;
844:                       do {
845:                           while (SW_pin != 0);
846:                           __delay_ms(50);
847:                           if (SW_pin == 0) {
848:                               while (SW_pin == 0);
849:                               s = 1;
850:                           } else {
851:                               s = 0;
852:                           }
853:                       } while (s == 0);
854:                   }
855:               }
856:           }
857:           #endif
858:           
859:           #if(ACTIVATE_EXAMPLE == 4)
860:           /* #4
861:            * Rotate led
862:            */
863:           #define _XTAL_FREQ 1000000 // 1 MHz
864:           
865:           void main(void) {
866:               TRISD = 0x00;
867:               while (1) {
868:                   unsigned char t;
869:                   for (t = 0x01; t > 0; t <<= 1) {
870:                       LATD = t;
871:                       __delay_ms(500);
872:                   }
873:               }
874:           }
875:           #endif
876:           
877:           #if(ACTIVATE_EXAMPLE == 3)
878:           /* #3
879:            * Blink LATD7 led
880:            */
881:           #define _XTAL_FREQ 1000000 // 1 MHz
882:           
883:           void main(void) {
884:               TRISD = 0b01111111;
885:               while (1) {
886:                   LATDbits.LATD7 = ~LATDbits.LATD7;
887:                   __delay_ms(500);
888:                   __delay_ms(500);
889:               }
890:           }
891:           #endif
892:           
893:           #if(ACTIVATE_EXAMPLE == 2)
894:           /* #2
895:            *  Blink LATD7 led
896:            */
897:           #define _XTAL_FREQ 1000000 // 1 MHz
898:           
899:           void main(void) {
900:               TRISD = 0b01111111;
901:               while (1) {
902:                   LATDbits.LATD7 = ~LATDbits.LATD7;
903:                   __delay_ms(500);
904:                   __delay_ms(500);
905:               }
906:           }
907:           #endif
908:           
909:           #if(ACTIVATE_EXAMPLE == 1)
910:           
911:           /* #1
912:            * Turn on LATD7 led
913:            */
914:           void main(void) {
915:               TRISD = 0b01111111;
916:               LATDbits.LATD7 = 1;
917:               while (1) {
918:                   ;
919:               }
920:           }
921:           #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.32/sources/pic18/plib/Flash/WriteBlockFlash.c  -------------
1:             #include "flash.h"
2:             
3:             /*********************************************************************
4:             Function:        	void WriteBlockFlash(unsigned long startaddr, unsigned char num_block, unsigned char *flash_array)
5:             
6:             PreCondition:    	None
7:             
8:             Input:           	startaddr - Strating address from which flash has to be written
9:             num_blocks - Number of blocks of flash to be written
10:             *flash_array - Pointer to array contents of which has to be written to flash
11:            
12:            Output:          	None
13:            
14:            Side Effects:    	Flash will be written in blocks of number of bytes specified in device data sheet
15:            
16:            Overview:        	The function writes flash from starting address in terms of number of bytes specified in device data sheet
17:            till end address or nearest multiple of number of bytes specified in device data sheet. If number of bytes between strating 
18:            and end address in not in multiples of number of bytes specified in device data sheet, write begins from address that is previous 
19:            nearest multiple of number of bytes specified in device data sheet 
20:            
21:            Note:            	1. Necessary to erase flash block (number of bytes specified in device data sheet) exclusively in application before writing 
22:            if application had written data into to this block of flash(after erasing followed by programming).
23:            2. Necessary to write interms block of number of bytes specified in device data sheet
24:            3. Writing can be done directly without erase if these bytes of flash is being written for the first time after programming
25:             ********************************************************************/
26:            #if defined (FLASH_V1_1) || defined (FLASH_V1_2) || defined (FLASH_V1_4) || defined (FLASH_V1_6)
27:            void WriteBlockFlash(unsigned long startaddr, unsigned char num_blocks, unsigned char *flash_array)
28:            {
29:            	unsigned char write_byte=0,flag=0;
0602  0E00     MOVLW 0x0
0604  6E0C     MOVWF write_byte, ACCESS
0606  0E00     MOVLW 0x0
0608  6E0D     MOVWF flag, ACCESS
30:            #ifndef _OMNI_CODE_
31:            	DWORD_VAL flash_addr;
32:            #else
33:            	char *startptr;
34:            	unsigned long saddress;
35:            #if _ERRATA_TYPES & ERRATA_TBLWTINT
36:            	unsigned char saved1,saved2,saved3,saved4;
37:            #endif    
38:            #endif
39:            
40:            	startaddr /=  FLASH_WRITE_BLOCK ;	//Allign the starting address block
060A  0E05     MOVLW 0x5
060C  6E08     MOVWF 0x8, ACCESS
060E  90D8     BCF STATUS, 0, ACCESS
0610  3204     RRCF 0x4, F, ACCESS
0612  3203     RRCF buffer_ptr, F, ACCESS
0614  3202     RRCF 0x2, F, ACCESS
0616  3201     RRCF __pcstackCOMRAM, F, ACCESS
0618  2E08     DECFSZ 0x8, F, ACCESS
061A  D7F9     BRA 0x60E
41:            	startaddr *= FLASH_WRITE_BLOCK ;
061C  0E05     MOVLW 0x5
061E  90D8     BCF STATUS, 0, ACCESS
0620  3601     RLCF __pcstackCOMRAM, F, ACCESS
0622  3602     RLCF 0x2, F, ACCESS
0624  3603     RLCF buffer_ptr, F, ACCESS
0626  3604     RLCF 0x4, F, ACCESS
0628  2EE8     DECFSZ WREG, F, ACCESS
062A  D7F9     BRA 0x61E
42:            
43:            #ifndef _OMNI_CODE_
44:            	flash_addr.Val = startaddr;
45:            #else
46:            	saddress = startaddr;
062C  C001     MOVFF __pcstackCOMRAM, saddress
062E  F00E     NOP
0630  C002     MOVFF 0x2, 0xF
0632  F00F     NOP
0634  C003     MOVFF buffer_ptr, 0x10
0636  F010     NOP
0638  C004     MOVFF 0x4, 0x11
063A  F011     NOP
47:            #endif
48:            
49:            	while(num_blocks--)
063C  D048     BRA 0x6CE
06CE  0605     DECF num_blocks, F, ACCESS
06D0  2805     INCF num_blocks, W, ACCESS
06D2  B4D8     BTFSC STATUS, 2, ACCESS
06D6  D7B3     BRA 0x63E
50:            	{
51:            #ifndef _OMNI_CODE_
52:            		TBLPTRU = flash_addr.byte.UB;						//Load the address to Address pointer registers
53:            		TBLPTRH = flash_addr.byte.HB;	
54:            		TBLPTRL	= flash_addr.byte.LB;
55:            #else
56:            		startptr = (const char *) saddress;
063E  C010     MOVFF 0x10, i
0640  F00B     NOP
0642  C00F     MOVFF 0xF, ptr
0644  F00A     NOP
0646  C00E     MOVFF saddress, ptr
0648  F009     NOP
57:            #if _ERRATA_TYPES & ERRATA_TBLWTINT
58:            		/* Errata document (B3,B4,B5) advises that these devices need all *
59:            		 * interrupt enable bits clear during TBLWT instruction.          *
60:            		 * (That document mentions INTCON2 but it has no 'enable' bits.)  */
61:            		saved1=INTCON; INTCON=0;	// Saving interrupt registers
62:            		saved2=INTCON3; INTCON3=0;
63:            		saved3=PIE1; PIE1=0;		
64:            		saved4=PIE2; PIE2=0;		
65:            #endif
66:            #endif
67:            
68:            		write_byte = FLASH_WRITE_BLOCK;
064A  0E20     MOVLW 0x20
064C  6E0C     MOVWF write_byte, ACCESS
69:            		while(write_byte--)
064E  D015     BRA 0x67A
067A  060C     DECF write_byte, F, ACCESS
067C  280C     INCF write_byte, W, ACCESS
067E  A4D8     BTFSS STATUS, 2, ACCESS
0680  D7E7     BRA 0x650
70:            		{
71:            #ifndef _OMNI_CODE_
72:            			TABLAT = *(flash_array++);
73:            			_asm  TBLWTPOSTINC 	_endasm
74:            #else
75:            				*startptr++ = *flash_array++;
0650  C006     MOVFF ptr, FSR2
0652  FFD9     NOP
0654  C007     MOVFF 0x7, FSR2H
0656  FFDA     NOP
0658  50DF     MOVF INDF2, W, ACCESS
065A  C009     MOVFF ptr, TBLPTR
065C  FFF6     NOP
065E  C00A     MOVFF ptr, TBLPTRH
0660  FFF7     NOP
0662  C00B     MOVFF i, TBLPTRU
0664  FFF8     NOP
0666  6EF5     MOVWF TABLAT, ACCESS
0668  000C     TBLWT*
066A  4A06     INFSNZ ptr, F, ACCESS
066C  2A07     INCF 0x7, F, ACCESS
066E  0E01     MOVLW 0x1
0670  2609     ADDWF ptr, F, ACCESS
0672  0E00     MOVLW 0x0
0674  220A     ADDWFC ptr, F, ACCESS
0676  0E00     MOVLW 0x0
0678  220B     ADDWFC i, F, ACCESS
76:            #endif
77:            		}	
78:            
79:            #if defined(_OMNI_CODE_) && (_ERRATA_TYPES & ERRATA_TBLWTINT) 
80:            		PIE1=saved3;		  // restore the interrupt registers
81:            		PIE2=saved4; 	
82:            		INTCON3=saved2;   
83:            		INTCON=saved1;           
84:            #endif
85:            #ifndef _OMNI_CODE_
86:            		TBLPTRU = flash_addr.byte.UB;						//Load the address to Address pointer registers
87:            		TBLPTRH = flash_addr.byte.HB;	
88:            		TBLPTRL	= flash_addr.byte.LB;
89:            #else
90:            		startptr = (const char *) saddress;
0682  C010     MOVFF 0x10, i
0684  F00B     NOP
0686  C00F     MOVFF 0xF, ptr
0688  F00A     NOP
068A  C00E     MOVFF saddress, ptr
068C  F009     NOP
91:            #endif
92:            		//*********** Flash write sequence ***********************************
93:            		EECON1bits.EEPGD = 1;  // point to Flash program memory       
068E  8EA6     BSF EECON1, 7, ACCESS
94:            		EECON1bits.CFGS = 0;  // access Flash program memory 
0690  9CA6     BCF EECON1, 6, ACCESS
95:            		EECON1bits.WREN = 1;
0692  84A6     BSF EECON1, 2, ACCESS
96:            		if(INTCONbits.GIE)
0694  AEF2     BTFSS INTCON, 7, ACCESS
0696  D003     BRA 0x69E
97:            		{
98:            			INTCONbits.GIE = 0;
0698  9EF2     BCF INTCON, 7, ACCESS
99:            			flag=1;
069A  0E01     MOVLW 0x1
069C  6E0D     MOVWF flag, ACCESS
100:           		}		  
101:           		EECON2 = 0x55;
069E  0E55     MOVLW 0x55
06A0  6EA7     MOVWF EECON2, ACCESS
102:           		EECON2 = 0xAA;
06A2  0EAA     MOVLW 0xAA
06A4  6EA7     MOVWF EECON2, ACCESS
103:           		EECON1bits.WR =1;
06A6  82A6     BSF EECON1, 1, ACCESS
104:           		EECON1bits.WREN = 0 ; 
06A8  94A6     BCF EECON1, 2, ACCESS
105:           		if(flag)
06AA  500D     MOVF flag, W, ACCESS
06AC  B4D8     BTFSC STATUS, 2, ACCESS
06AE  D003     BRA 0x6B6
106:           		{
107:           			INTCONbits.GIE = 1;	
06B0  8EF2     BSF INTCON, 7, ACCESS
108:           			flag=0;
06B2  0E00     MOVLW 0x0
06B4  6E0D     MOVWF flag, ACCESS
109:           		}
110:           #ifndef _OMNI_CODE_
111:           		flash_addr.Val = flash_addr.Val + FLASH_WRITE_BLOCK;									//increment to one block of 64 bytes
112:           #else
113:           		saddress = saddress + FLASH_WRITE_BLOCK;									//increment to one block of 64 bytes
06B6  0E20     MOVLW 0x20
06B8  240E     ADDWF saddress, W, ACCESS
06BA  6E0E     MOVWF saddress, ACCESS
06BC  0E00     MOVLW 0x0
06BE  200F     ADDWFC 0xF, W, ACCESS
06C0  6E0F     MOVWF 0xF, ACCESS
06C2  0E00     MOVLW 0x0
06C4  2010     ADDWFC 0x10, W, ACCESS
06C6  6E10     MOVWF 0x10, ACCESS
06C8  0E00     MOVLW 0x0
06CA  2011     ADDWFC 0x11, W, ACCESS
06CC  6E11     MOVWF 0x11, ACCESS
114:           #endif
115:           	}
116:           }
06D4  0012     RETURN 0
117:           
118:           #elif defined (FLASH_V1_3) || defined (FLASH_V1_5) || defined (FLASH_V2_1)  
119:           void WriteBlockFlash(unsigned long startaddr, unsigned char num_blocks, unsigned char *flash_array)
120:           {
121:           	unsigned char write_byte=0,flag=0;
122:           #ifndef _OMNI_CODE_
123:           	DWORD_VAL flash_addr;
124:           #else
125:           	char *startptr;
126:           	unsigned long saddress;
127:           #if _ERRATA_TYPES & ERRATA_TBLWTINT
128:           	unsigned char saved1,saved2,saved3,saved4;
129:           #endif    
130:           #endif
131:           
132:           	startaddr /=  FLASH_WRITE_BLOCK ;	//Allign the starting address block
133:           	startaddr *= FLASH_WRITE_BLOCK ;
134:           
135:           #ifndef _OMNI_CODE_
136:           	flash_addr.Val = startaddr;
137:           #else
138:           	saddress = startaddr;
139:           #endif
140:           
141:           	while(num_blocks--)
142:           	{
143:           #ifndef _OMNI_CODE_
144:           		TBLPTRU = flash_addr.byte.UB;						//Load the address to Address pointer registers
145:           		TBLPTRH = flash_addr.byte.HB;	
146:           		TBLPTRL	= flash_addr.byte.LB;
147:           #else
148:           		startptr = (const char *) saddress;
149:           #if _ERRATA_TYPES & ERRATA_TBLWTINT
150:           		/* Errata document (B3,B4,B5) advises that these devices need all *
151:           		 * interrupt enable bits clear during TBLWT instruction.          *
152:           		 * (That document mentions INTCON2 but it has no 'enable' bits.)  */
153:           		saved1=INTCON; INTCON=0;	// Saving interrupt registers
154:           		saved2=INTCON3; INTCON3=0;
155:           		saved3=PIE1; PIE1=0;		
156:           		saved4=PIE2; PIE2=0;		
157:           #endif
158:           #endif
159:           
160:           		write_byte = FLASH_WRITE_BLOCK;
161:           		while(write_byte--)
162:           		{
163:           #ifndef _OMNI_CODE_
164:           			TABLAT = *(flash_array++);
165:           			_asm  TBLWTPOSTINC 	_endasm
166:           #else
167:           				*startptr++ = *flash_array++;
168:           #endif
169:           		}	
170:           
171:           #if defined(_OMNI_CODE_) && (_ERRATA_TYPES & ERRATA_TBLWTINT) 
172:           		PIE1=saved3;		  // restore the interrupt registers
173:           		PIE2=saved4; 	
174:           		INTCON3=saved2;   
175:           		INTCON=saved1;           
176:           #endif
177:           #ifndef _OMNI_CODE_
178:           		TBLPTRU = flash_addr.byte.UB;						//Load the address to Address pointer registers
179:           		TBLPTRH = flash_addr.byte.HB;	
180:           		TBLPTRL	= flash_addr.byte.LB;
181:           #else
182:           		startptr = (const char *) saddress;
183:           #endif
184:           		//*********** Flash write sequence ***********************************
185:           		EECON1bits.WREN = 1;
186:           		if(INTCONbits.GIE)
187:           		{
188:           			INTCONbits.GIE = 0;
189:           			flag=1;
190:           		}		  
191:           		EECON2 = 0x55;
192:           		EECON2 = 0xAA;
193:           		EECON1bits.WR =1;
194:           		EECON1bits.WREN = 0 ; 
195:           		if(flag)
196:           		{
197:           			INTCONbits.GIE = 1;	
198:           			flag=0;
199:           		}
200:           #ifndef _OMNI_CODE_
201:           		flash_addr.Val = flash_addr.Val + FLASH_WRITE_BLOCK;									//increment to one block of 64 bytes
202:           #else
203:           		saddress = saddress + FLASH_WRITE_BLOCK;									//increment to one block of 64 bytes
204:           #endif
205:           	}
206:           }
207:           #endif
208:           
